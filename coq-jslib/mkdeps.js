/**
 * makedeps.js
 * Reads cross-module dependencies from a .xxx.d file (generated by coqdep)
 */

const mkpkg = require('./mkpkg');


class ModuleDeps {

    constructor(loadpath, fileext) {
        this.loadpath = loadpath || [];
        this.fileext = fileext || ".vo";
        this.deps = {};
    }

    fromFile(filename) {
        var fs = require('fs');
        return this.fromText(fs.readFileSync(filename, 'utf-8'));
    }

    fromFiles(filenames) {
        return filenames.reduce((o, fn) => o.fromFile(fn), this);
    }

    fromText(dep_text) {
        for (let line of dep_text.split(/\n+/)) {
            let [lhs, rhs] = this.readDepLine(line);
            for (let u of lhs) {
                this.deps[u] = (this.deps[u] || []).concat(rhs);
            }
        }
        return this;
    }

    depsOfPackage(pkg) {
        var pkg_deps = {};
        for (let m of pkg.listModules()) {
            if (this.deps.hasOwnProperty(m)) {
                var mdeps = this.deps[m];
                if (mdeps && mdeps.length)
                    pkg_deps[m] = mdeps;
            }
        }
        return pkg_deps;
    }

    readDepLine(line) {
        var mo = /^([^:]+):([^:]*)$/.exec(line);
        if (!mo) return [[], []];
        return [mo[1], mo[2]].map(s => this.filenamesToModuleNames(s));
    }

    filenamesToModuleNames(s) {
        return s.trim().split(/\s+/)
            .map(e => this.filenameToModuleName(e)).filter(e => e);
    }

    filenameToModuleName(s) {
        if (s.endsWith(this.fileext)) {
            var name = s.slice(0, s.length - this.fileext.length);
            for (let [mod_path, phys_path] of this.loadpath) {
                if (name.startsWith(phys_path + "/")) {
                    name = `${mod_path}.${name.slice(phys_path.length + 1)}`;
                    break;
                }
            }
            return name.replace(/[/]/g, '.');
        }
        else return null;
    }
}



if (typeof module !== 'undefined' && module.id == '.') {
    var pkg_jsons = process.argv.slice(2).filter(x => !/[.]d$/.exec(x)),
        coqdep = process.argv.slice(2).filter(x => /[.]d$/.exec(x)),
        loadpath = [['Coq', 'theories'], ['Coq', 'plugins']];

    if (coqdep.length === 0) coqdep = ['coq-external/coq-v8.10+32bit/.vfiles.d'];

    var md = new ModuleDeps(loadpath).fromFiles(coqdep);

    for (let json_fn of pkg_jsons) {
        let pd = mkpkg.PackageDefinition.fromFile(json_fn),
            pkg_deps = md.depsOfPackage(pd);

        if (Object.keys(pkg_deps).length > 0) {
            pd.manifest.modDeps = pkg_deps;
            pd.writeManifest();
        }
    }
}